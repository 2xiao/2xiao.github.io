# 10. 实现单节点 update

::: info 摘要

- 浏览器环境 DOM 的删除（比如 h3 变为 p，那么就要经历删除 h3、插入 p）
  插入单节点的 reconcile 流程（包括 HostComponent、HostText）
  删除节点的 reconcile 流程（为后续 ref、useEffect 特性做准备，实现的比较完备）
  Hooks 架构 update 时实现

相关代码可在 [`git tag v1.9`](https://github.com/2xiao/my-react/tree/v1.9) 查看

:::

在[第 8 节](./8.md)中，我们已经完成了组件首次渲染时的 `useState` 方法，现在我们将继续实现更新时的 `useState` 方法。在更新流程和首次渲染流程中，存在一些关键区别：

- 对于 `beginWork` 阶段：
  - 需要处理节点删除的情况（`Deletion`）；
  - 需要处理节点移动的情况（例如从 `abc` 变为 `bca`）；
- 对于 `completeWork` 阶段：
  - 需要处理 `HostText` 内容的更新情况；
  - 需要处理 `HostComponent` 属性的变化情况；
- 对于 `commitWork` 阶段：
  - 当出现 `Deletion` 时，需要遍历被删除的子树；
- 对于 `useState` 方法：
  - 需要实现与 `mountState` 相对应的 `updateState` 方法；

## 1. 处理 beginWork 阶段

在本节中，我们仅处理单一节点的情况，先跳过多节点的情况，因此也不需要考虑节点移动的情况。具体的处理流程如下：

- 首先，我们需要比较是否可以复用当前的 Fiber 节点。

  - 首先比较节点的 `key`，如果 `key` 不同，表示不能复用。
  - 如果 `key` 相同，则继续比较节点的 `type`，如果 `type` 不同，同样不能复用。
  - 如果 `key` 和 `type` 都相同，表示可以复用。

- 如果不能复用当前的 Fiber 节点，则需要标记删除当前的 Fiber 节点，并创建一个新的 Fiber 节点。
- 如果可以复用，就直接复用旧的 Fiber 节点。

```ts
// 处理单个 Fragment 节点的情况
// 对比 currentFiber 与 ReactElement，生成 workInProgress FiberNode
function reconcileSingleElement(
	returnFiber: FiberNode,
	currentFiber: FiberNode | null,
	element: ReactElementType
) {
	if (currentFiber !== null) {
		// 组件的更新阶段
		if (
			currentFiber.key === element.key &&
			currentFiber.type === element.type &&
			element.type === REACT_ELEMENT_TYPE
		) {
			// 复用旧的 Fiber 节点
			const existing = useFiber(currentFiber, element.props);
			existing.return = returnFiber;
			return existing;
		} else {
			// 删除旧的 Fiber 节点
			deleteChild(returnFiber, currentFiber);
		}
	}
	// 创建新的 Fiber 节点
	const fiber = createFiberFromElement(element);
	fiber.return = returnFiber;
	return fiber;
}

// 处理文本节点的情况
// 对比 currentFiber 与 ReactElement，生成 workInProgress FiberNode
function reconcileSingleTextNode(
	returnFiber: FiberNode,
	currentFiber: FiberNode | null,
	content: string | number
) {
	if (currentFiber !== null) {
		// 组件的更新阶段
		if (currentFiber.tag === HostText) {
			// 复用旧的 Fiber 节点
			const existing = useFiber(currentFiber, { content });
			existing.return = returnFiber;
			return existing;
		} else {
			// 删除旧的 Fiber 节点
			deleteChild(returnFiber, currentFiber);
		}
	}
	// 创建新的 Fiber 节点
	const fiber = new FiberNode(HostText, { content }, null);
	fiber.return = returnFiber;
	return fiber;
}
```

在 `useFiber` 函数中，我们实现了复用旧的 Fiber 节点的功能。需要注意的是，对于同一个 Fiber 节点，在多次更新中，`current` 和 `workInProgress` 这两个 Fiber 节点会被反复重用。

这是因为在 React 中，每个 Fiber 节点都有一个 `alternate` 指针，指向其在上一次渲染中对应的 Fiber 节点。在 `createWorkInProgress` 函数中，我们通过 `current.alternate` 指针获取了上一次渲染中对应的 Fiber 节点 `workInProgress`，并且返回了经过处理后的 `workInProgress`，这种重用机制有助于减少内存消耗和提高性能。

```ts
// 复用 Fiber 节点
function useFiber(fiber: FiberNode, pendingProps: Props): FiberNode {
	const clone = createWorkInProgress(fiber, pendingProps);
	clone.index = 0;
	clone.sibling = null;
	return clone;
}
```

在 `deleteChild` 函数中，我们实现了删除旧的 Fiber 节点的功能。具体来说，就是将旧的 Fiber 节点加入到其父节点的 `deletions` 参数中，并为其父节点增加 `Deletion` flags 标记。

`deletions` 参数是一个数组，用于记录需要被删除的节点，然后在适当的时机，React 会遍历 deletions 数组，执行相应节点的删除操作。

```ts
// 从父节点中删除指定的子节点
function deleteChild(returnFiber: FiberNode, childToDelete: FiberNode): void {
	if (!shouldTrackSideEffects) {
		return;
	}
	const deletions = returnFiber.deletions;
	if (deletions === null) {
		returnFiber.deletions = [childToDelete];
		returnFiber.flags |= Deletion;
	} else {
		deletions.push(childToDelete);
	}
}
```

## 2. 处理 completeWork 阶段

在 `completeWork` 阶段，会根据 Fiber 节点的类型（`HostRoot`、`HostComponent`、`HostText` 等）构建 DOM 节点，收集更新 flags，并根据更新 flags 执行不同的 DOM 操作。

之前我们已经实现首屏渲染时的 `completeWork` 函数，现在只需要在其中增加组件更新的情况处理，分别是：

- 处理 `HostComponent` 属性的变化情况；
- 处理 `HostText` 内容的更新情况；

```ts
// 生成更新计划，计算和收集更新 flags
export const completeWork = (workInProgress: FiberNode) => {
	const newProps = workInProgress.pendingProps;
	const current = workInProgress.alternate;
	switch (workInProgress.tag) {
		// ...

		case HostComponent:
			if (current !== null && workInProgress.stateNode != null) {
				// 组件的更新阶段
				updateHostComponent(current, workInProgress);
			}
		// ...

		case HostText:
			if (current !== null && workInProgress.stateNode !== null) {
				// 组件的更新阶段
				updateHostText(current, workInProgress);
			}
		// ...
	}
};

function updateHostText(current: FiberNode, workInProgress: FiberNode) {
	const oldText = current.memoizedProps.content;
	const newText = workInProgress.pendingProps.content;
	if (oldText !== newText) {
		markUpdate(workInProgress);
	}
}

function updateHostComponent(current: FiberNode, workInProgress: FiberNode) {
	const oldProps = current.memoizedProps;
	const newProps = workInProgress.pendingProps;

	if (oldProps !== newProps) {
		markUpdate(workInProgress);
	}
}

// 为 Fiber 节点增加 Update flags
function markUpdate(workInProgress: FiberNode) {
	workInProgress.flags |= Update;
}
```

## 3. 处理 commitWork 阶段

## 4. 处理 useState 方法
